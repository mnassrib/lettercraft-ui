name: CI/CD Pipeline

# Déclenchement du workflow via repository_dispatch suite à la réception d'un événement depuis le dépôt privé
on:
  repository_dispatch:
    types: [deploy]

jobs:
  ci_cd:
    runs-on: ubuntu-latest
    env:
      SECRET_KEY: ${{ secrets.SECRET_KEY }}
      RECAPTCHA_SITE_KEY: ${{ secrets.RECAPTCHA_SITE_KEY }}
      RECAPTCHA_SECRET_KEY: ${{ secrets.RECAPTCHA_SECRET_KEY }}
      FLASK_ENV: testing
      DATABASE_URL: postgresql://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@localhost:5432/lettercraft_test_db

    steps:

      # ====================== PARTIE 1: Tests sur GitHub sans conteneurisation ======================

      # Étape 1 : Cloner le dépôt privé contenant le code source de l'application
      - name: Checkout code from the private repository
        uses: actions/checkout@v3
        with:
          repository: mnassrib/lettercraft-backend
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      # Étape 2 : Configurer l'environnement Python
      - name: Set up Python 3.10
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      # Étape 3 : Configurer PostgreSQL pour la base de données
      - name: Set up PostgreSQL database service
        uses: Harmon758/postgresql-action@v1.0.0
        with:
          postgresql_version: '13'
          postgresql_db: lettercraft_test_db
          postgresql_user: ${{ secrets.POSTGRES_USER }}
          postgresql_password: ${{ secrets.POSTGRES_PASSWORD }}

      # Étape 4 : Redémarrer PostgreSQL (si nécessaire)
      - name: Restart PostgreSQL
        run: sudo service postgresql restart

      # Étape 7 : Attendre activement que PostgreSQL soit prêt
      - name: Wait for PostgreSQL to be ready
        run: |
          max_retries=6
          retry_count=0
          until pg_isready -h localhost -p 5432 || [ $retry_count -eq $max_retries ]; do
            echo "Waiting for PostgreSQL... Retry count: $((++retry_count))"
            sleep 10  
          done
          if [ $retry_count -eq $max_retries ]; then
            echo "PostgreSQL is not ready after $max_retries attempts, exiting."
            exit 1
          fi

      # Étape 8 : Définir les variables d'environnement 
      - name: Set environment variables
        run: |
          echo "SECRET_KEY=${{ secrets.SECRET_KEY }}" >> $GITHUB_ENV
          echo "RECAPTCHA_SITE_KEY=${{ secrets.RECAPTCHA_SITE_KEY }}" >> $GITHUB_ENV
          echo "RECAPTCHA_SECRET_KEY=${{ secrets.RECAPTCHA_SECRET_KEY }}" >> $GITHUB_ENV
          echo "FLASK_ENV=testing" >> $GITHUB_ENV
          echo "DATABASE_URL=postgresql://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@localhost:5432/lettercraft_test_db" >> $GITHUB_ENV

      - name: Set PostgreSQL password for postgres
        run: |
          cd /tmp
          sudo -u postgres psql -c "ALTER USER postgres WITH PASSWORD '${{ secrets.POSTGRES_PASSWORD }}';"
      

      # Étape 5 : Vérifier si l'utilisateur PostgreSQL existe
      - name: Check if PostgreSQL user exists
        run: |
          psql -h localhost -p 5432 -U postgres -d postgres -c "SELECT 1 FROM pg_roles WHERE rolname = '${{ secrets.POSTGRES_USER }}';"
        env:
          PGPASSWORD: ${{ secrets.POSTGRES_PASSWORD }}

      # Étape : Test de connexion manuelle avant l'upgrade de la base de données
      - name: Test PostgreSQL connection
        run: |
          psql -h localhost -p 5432 -U ${{ secrets.POSTGRES_USER }} -d lettercraft_test_db -c "SELECT 1"
        env:
          PGPASSWORD: ${{ secrets.POSTGRES_PASSWORD }}

      # Étape 9 : Installer les dépendances du projet et appliquer les migrations des données pour synchroniser le schéma
      - name: Install dependencies and run migrations
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          flask db upgrade

      # Étape 10 : Exécuter les tests unitaires sur l'application sans conteneurisation
      - name: Run tests
        run: |
          pytest

      # ====================== PARTIE 2: Tests en conteneur pour simuler un environnement de production ======================

      # Étape 11 : Construire l'image Docker pour l'application en utilisant le Dockerfile
      - name: Build Docker image
        run: |
          docker build -t lettercraft .

      # Étape 12 : Lancer un conteneur Docker et tester l'application dans un environnement en mode "testing"
      - name: Run Docker container for testing
        run: |
          docker run -d -e SECRET_KEY=$SECRET_KEY \
                    -e RECAPTCHA_SITE_KEY=$RECAPTCHA_SITE_KEY \
                    -e RECAPTCHA_SECRET_KEY=$RECAPTCHA_SECRET_KEY \
                    -e DATABASE_URL=postgresql://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@localhost:5432/lettercraft_test_db \
                    -e FLASK_ENV=$FLASK_ENV \
                    --name lettercraft-test lettercraft
          docker exec lettercraft-test pytest
          docker stop lettercraft-test
          docker rm lettercraft-test

      # ====================== PARTIE 3: Appliquer les migrations en production et déployer sur Render ======================

      # Étape 13 : Appliquer les migrations sur la base de données de Render (avant déploiement)
      - name: Migrate Database on Render
        run: |
          docker run --rm -e DATABASE_URL=${{ secrets.DATABASE_URL }} lettercraft flask db upgrade

      # Étape 14 : Déployer l'application sur Render après validation des migrations
      - name: Deploy to Render
        run: |
          curl -X POST ${{ secrets.RENDER_DEPLOY_HOOK }} \
            -H 'Authorization: Bearer ${{ secrets.RENDER_API_KEY }}' \
            -H 'Accept: application/json' \
            -d ''

      # Étape 15 (optionnelle) : Notifier de la réussite du déploiement
      - name: Notify deployment success
        run: echo "Deployment to Render was successful!"