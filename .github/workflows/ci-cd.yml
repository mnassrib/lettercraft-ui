name: CI/CD Pipeline

# Déclenchement du workflow via repository_dispatch suite la réception d'un événement depuis le dépôt privé)
on:
  repository_dispatch:
    types: [deploy]

jobs:
  ci_cd:
    runs-on: ubuntu-latest  

    steps:

      # ====================== PARTIE 1: Tests sur GitHub sans conteneurisation ======================

      # Étape 1 : Cloner le dépôt privé contenant le code source de l'application
      - name: Checkout code from the private repository
        uses: actions/checkout@v3
        with:
          repository: mnassrib/lettercraft-backend  
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}  

      # Étape 2 : Configurer l'environnement Python
      - name: Set up Python 3.10
        uses: actions/setup-python@v4  
        with:
          python-version: '3.10' 

      # Étape 3 : Définir les variables d'environnement à partir des secrets GitHub
      - name: Set environment variables from GitHub Secrets
        run: |
          echo "SECRET_KEY=${{ secrets.SECRET_KEY }}" >> $GITHUB_ENV  
          echo "RECAPTCHA_SITE_KEY=${{ secrets.RECAPTCHA_SITE_KEY }}" >> $GITHUB_ENV  
          echo "RECAPTCHA_SECRET_KEY=${{ secrets.RECAPTCHA_SECRET_KEY }}" >> $GITHUB_ENV  
          echo "DATABASE_URL=${{ secrets.DATABASE_URL }}" >> $GITHUB_ENV  

      # Étape 4 : Installer les dépendances du projet et appliquer les migrations des données pour synchroniser le schéma
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip  
          pip install -r requirements.txt  
          flask db upgrade  

      # Étape 5 : Exécuter les tests unitaires sur l'application sans conteneurisation
      - name: Run tests
        run: |
          pytest --maxfail=5 --disable-warnings  # Exécuter les tests avec pytest, arrêter après 5 échecs max


      # ====================== PARTIE 2: Tests en conteneur pour simuler un environnement de production ======================

      # Étape 6 : Construire l'image Docker pour l'application en utilisant le Dockerfile
      - name: Build Docker image
        run: |
          docker build -t lettercraft .  

      # Étape 7 : Lancer un conteneur Docker et tester l'application dans un environnement en mode "testing"
      - name: Run Docker container for testing
        run: |
          docker run -d -e SECRET_KEY=${{ secrets.SECRET_KEY }} \  
                    -e RECAPTCHA_SITE_KEY=${{ secrets.RECAPTCHA_SITE_KEY }} \
                    -e RECAPTCHA_SECRET_KEY=${{ secrets.RECAPTCHA_SECRET_KEY }} \
                    -e DATABASE_URL=${{ secrets.DATABASE_URL }} \
                    -e FLASK_ENV='testing' \  
                    --name lettercraft-test lettercraft  
          docker exec lettercraft-test pytest  
          docker stop lettercraft-test  
          docker rm lettercraft-test  


      # ====================== PARTIE 3: Appliquer les migrations en production et déployer sur Render ======================

      # Étape 8 : Appliquer les migrations sur la base de données de Render (avant déploiement)
      - name: Migrate Database on Render
        run: |
          curl -X POST ${{ secrets.RENDER_API_URL }}/v1/services/${{ secrets.RENDER_SERVICE_ID }}/migrate \  
            -H 'Authorization: Bearer ${{ secrets.RENDER_API_KEY }}' \
            -H 'Accept: application/json'

      # Étape 9 : Déployer l'application sur Render après validation des migrations
      - name: Deploy to Render
        run: |
          curl -X POST ${{ secrets.RENDER_DEPLOY_HOOK }}  \  
            -H 'Authorization: Bearer ${{ secrets.RENDER_API_KEY }}' \
            -H 'Accept: application/json' \
            -d ''  

      # Étape 10 (optionnelle) : Notifier de la réussite du déploiement
      - name: Notify deployment success
        run: echo "Deployment to Render was successful!"  